我们需要提供一个有着**类、函数、普通顶层代码**的相对复杂的 `evaltime.py` 文件，还需要在这个文件中再导入另一个 `evalsupport.py` 文件，**用以观察在各种不同条件下的行为**，`evaltime.py`代码如下：

> 以下代码都是《流畅的 python》第二十一章第三节的源码，作者 Luciano Ramalho 也是通过这两个类来总结导入时与运行时的行为差异，我觉得设计的很好。

```python
from evalsupport import deco_alpha

print('<[1]> evaltime module start')

class ClassOne():
    print('<[2]> ClassOne body')

    def __init__(self):
        print('<[3]> ClassOne.__init__')

    def __del__(self):
        print('<[4]> ClassOne.__del__')

    def method_x(self):
        print('<[5]> ClassOne.method_x')

    class ClassTwo(object):
        print('<[6]> ClassTwo body')

@deco_alpha
class ClassThree():
    print('<[7]> ClassThree body')

    def method_y(self):
        print('<[8]> ClassThree.method_y')

class ClassFour(ClassThree):
    print('<[9]> ClassFour body')

    def method_y(self):
        print('<[10]> ClassFour.method_y')

if __name__ == '__main__':
    print('<[11]> ClassOne tests', 30 * '.')
    one = ClassOne()
    one.method_x()
    print('<[12]> ClassThree tests', 30 * '.')
    three = ClassThree()
    three.method_y()
    print('<[13]> ClassFour tests', 30 * '.')
    four = ClassFour()
    four.method_y()

print('<[14]> evaltime module end')
```

`evalsupport.py`代码如下：

```python
print('<[100]> evalsupport module start')

def deco_alpha(cls):
    print('<[200]> deco_alpha')

    def inner_1(self):
        print('<[300]> deco_alpha:inner_1')

    cls.method_y = inner_1
    return cls


class MetaAleph(type):
    print('<[400]> MetaAleph body')

    def __init__(cls, name, bases, dic):
        print('<[500]> MetaAleph.__init__')

        def inner_2(self):
            print('<[600]> MetaAleph.__init__:inner_2')

        cls.method_z = inner_2


print('<[700]> evalsupport module end')
```

### 导入的解析

在 **python 命令行**中运行 `import evaltime.py` 会得到以下输出：

```
<[100]> evalsupport module start
<[400]> MetaAleph body 
<[700]> evalsupport module end 
<[1]> evaltime module start 
<[2]> ClassOne body 
<[6]> ClassTwo body 
<[7]> ClassThree body 
<[200]> deco_alpha 
<[9]> ClassFour body 
<[14]> evaltime module end
```

下面对上面的 10 行代码做出解释：

1. 导入时，python **会执行 `evaltime.py` 所导入的 `evalsupport.py` 模块中的所有顶层代码。**
2. `evalsupport.py` 中的 deco_alpha 方法体没有执行，**实际上 python 编译了 deco_alpha 函数，但是不会执行定义体**。**MetaAleph 类的定义体运行了**，但是其中的 `__init__` magic 方法没有执行。
3. 原因见 1
4. python 会**执行 `evaltime.py` 的所有顶层代码。**
5. ClassOne 的类定义体也执行了、但是类方法没有执行。
6. **嵌套于 ClassOne 的 ClassTwo 类的定义体也执行了。**
7. ClassThree 的**类定义体先于它的类装饰器方法体执行了。**
8. **类装饰器 deco_alpha 在被其装饰的 ClassThree 后执行了方法体**，但是嵌套其中的函数 `inner_1` 没有执行。
9. ClassFour 类执行了类方法体，但是貌似与其父类 ClassThree 没有关联。
10. 原因见 4

**值得注意的是：这些输出只会在首次 import 时看见**，之后再次 import 就不会有任何输出了。

**原因是：**在首次导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于执行的字节码，并将其存入 `__pycache__` 的 .pyc 文件中。如果有句法错误，则会在此时报告。

当本地的 `__pycache__` 文件中有最新的 .pyc 文件，那么解释器则会跳过上述步骤，因为已经有运行所需的字节码了。

#### 导入时总结:

在 python 命令行**首次输入** `import A` 时会按照**代码顺序**执行以下几条：

1. **会执行模块 A 中的所有顶层代码。**
2. **会执行模块 A 导入的所有模块的顶层代码(上例中的 evalsupport.py)。**
3. 执行的顶层代码中
   1. **若是类的定义体，那么会执行类的定义体、但是只会编译类方法，不会执行类方法定义体。**
   2. **若是函数，则解释器只会编译此函数，不会执行函数定义体。**
4. 在执行的类的定义体中
   1. **若是嵌套类**，那么会执行嵌套类的定义体，规则与第三条规则中的类定义体情况一致。
   2. 若该类被装饰、**在执行完类定义体后执行装饰器函数定义体。**
   3. 与该类是否是某个类的子类无关（正常执行）。
5. 执行装饰器函数定义体中
   1. **若是嵌套函数，那么只会编译此函数，不会执行该函数定义体。**

总结来说、首次导入时，所有的顶层代码都会执行，包括在此模块中导入的其他模块的顶层代码；此外，类的定义体也会被执行；除了装饰器函数的定义体会在被装饰的类/函数执行过后执行，**其他的所有函数只会被解释器编译，不会执行函数定义体。**

> `if __name__ == ‘__main__’` 属于顶层代码，只是此时这个语句的结果为 False，原因后面会提到。

> 被编译器编译的意思是：将其解析成可执行的字节码，换言之**就是做了全局名称绑定，以便以后要使用时找到它。**

> 对于类而言，被编译器编译后，定义了类的属性和方法，并构建了类对象。





参考：[python 导入时与运行时 - 半天钟的博客 | Btz Blog (halfclock.github.io)](https://halfclock.github.io/2019/06/07/python-import-and-running/)