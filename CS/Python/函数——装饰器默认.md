### property

修改方法，使方法可以像属性一样访问，

我们可以使用@property装饰器来创建**只读属性**，@property装饰器会将**方法**转换为相同名称的**只读属性**,可以与所定义的属性配合使用，这样可以防止属性被修改。

### setter

python中用”.”操作来访问和改写类的属性成员时，会调用__get__和__set__方法，模式情况下，python会查找class.__dict__字典，对对应值进行操作。比如C.x会调用C.__get__访问最终读取C.__dict__[x]元素。

如果需要读取时对输出结果进行修饰或者对输入进行合法化检查，通常做法是自己写get和set函数，并通过调get和set函数进行读写类成员属性。


```python
class Timer:

  def __init__(self, value = 0.0):
    self._time = value
    self._unit = 's'

  # 使用装饰器的时候，需要注意：
  # 1. 装饰器名，函数名需要一直
  # 2. property需要先声明，再写setter，顺序不能倒过来
  @property
  def time(self):
    return str(self._time) + ' ' + self._unit

  @time.setter
  def time(self, value):
    if(value < 0):
      raise ValueError('Time cannot be negetive.')
    self._time = value

t = Timer()
t.time = 1.0
print(t.time)
```

这两个装饰器
@property装饰器会把成员函数x转换为getter，相当于做了x = property(); x = x.getter(x_get)
@x.setter装饰器会把成员函数x转换为setter，相当于做了x = x.seter(x_set).

可以看到我们实现了通过属性x来对私有变量_x进行操作。

### staticmethod classmethod

不需要实例化，直接类名.方法名()来调用。

这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。

1. 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。
2. 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。
3. 如果需要调用带self的方法，必须得先对类进行实例化。
   

```python
class Test(object):
    name = 'stephen'
    """docstring for Test"""
def __init__(self, arg=None):
    super(Test, self).__init__()
    self.arg = arg

def say_hi(self):
    print '[1]hello wrold'

@staticmethod
def say_bad():
    print '[2]say bad'
    print '[3]Test.name:%s'%Test.name  //不需要实例化
    Test().say_hi() //先要实例化，才能调用say_hi()

@classmethod
def say_good(cls):
    print '[4]say good'
    print '[5]cls.name:%s'%cls.name //不需要实例化
    cls.say_bad() //不需要实例化
    cls().say_hi()  //先要实例化，才能调用say_hi()
def main():
    Test.say_bad()
    print "----------------------------------"
    Test.say_good()

if __name__ == '__main__':
    main()

```

