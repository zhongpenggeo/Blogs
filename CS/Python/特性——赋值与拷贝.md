---
title: 特性——赋值与拷贝
date: 2021-07-27 10:04:43
categories:
- Python
---


### 1. 赋值（assignment）

在Python中，用一个变量给另一个变量**赋值**，其实就是给当前内存中的对象增加一个“标签”而已。

```shell
>>> a = [1, 2, 3]
>>> b = a
>>> print(id(a), id(b), sep='\n')
139701469405552
139701469405552
```



**但是如果做了操作之后，就会改变内存位置**；

```shell
>>> a= 1.0
>>> id(a)
139977871174256
>>> b=a
>>> id(b)
139977871174256
>>> b=2.0
>>> id(b)
139977871174096
>>> a=3.0
>>> id(a)
139977836864400
>>>
```

**但是对于列表之类的连续变量而言,改变元素（改变元素值，改变位置）不会重新分配内存**：

```shell
>>> a=[1,2,3]
>>> b=a
>>> id(a)
139977836511312
>>> id(b)
139977836511312
>>> a+=[4,5]
>>> a
[1, 2, 3, 4, 5]
>>> id(a)
139977836511312
>>> b
[1, 2, 3, 4, 5]
>>>
```

所以注意以下的赋值与引用

#### 1.1 增强赋值与共享引用

x = x + y，x 出现两次，必须执行两次，性能不好，**合并必须新建对象 x，然后复制两个列表合并**

**属于复制/拷贝**

x += y，x 只出现一次，也只会计算一次，性能好，**不生成新对象，只在内存块末尾增加元素**。

当 x、y 为list时， += 会自动调用 extend 方法进行合并运算，in-place change。

属于共享引用

```shell
L = [1, 2]
M = L
L = L + [3, 4]
print L, M
print "-------------------"
L = [1, 2]
M = L
L += [3, 4]
print L, M


[1, 2, 3, 4] [1, 2]
-------------------
[1, 2, 3, 4] [1, 2, 3, 4]
```



### 2. 浅拷贝（shallow copy）

**注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。**



所谓“浅拷贝”，是指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）

常见的浅拷贝有：切片操作、工厂函数、对象的copy()方法、copy模块中的copy函数。

```shell
>>> a = [1, 2, 3]
>>> b = list(a)
>>> print(id(a), id(b))          # a和b身份不同
140601785066200 140601784764968
>>> for x, y in zip(a, b):       # 但它们包含的子对象身份相同
...     print(id(x), id(y))
... 
140601911441984 140601911441984
140601911442016 140601911442016
140601911442048 140601911442048
```

a 浅拷贝得到 b，a 和 b 指向内存中不同的 **list** 对象，但它们的元素却指向相同的 **int** 对象。这就是浅拷贝！

### 3. 深拷贝deep copy）

所谓“深拷贝”，是指创建一个新的对象，然后递归的拷贝原对象所包含的子对象。深拷贝出来的对象与原对象没有任何关联。

深拷贝只有一种方式：copy模块中的deepcopy函数。

```shell
>>> import copy
>>> a = [1, 2, 3]
>>> b = copy.deepcopy(a)
>>> print(id(a), id(b))
140601785065840 140601785066200
>>> for x, y in zip(a, b):
...     print(id(x), id(y))
... 
140601911441984 140601911441984
140601911442016 140601911442016
140601911442048 140601911442048
```

对于**不可变对象**，当需要一个新的对象时，python可能会返回已经存在的某个类型和值都一致的对象的引用。而且这种机制并不会影响 a 和 b 的相互独立性，因为当两个元素指向同一个不可变对象时，对其中一个赋值不会影响另外一个。



### 4. 深拷贝与浅拷贝

```shell
>>> import copy
>>> a = [[1, 2],[5, 6], [8, 9]]
>>> b = copy.copy(a)              # 浅拷贝得到b
>>> c = copy.deepcopy(a)          # 深拷贝得到c
>>> print(id(a), id(b))           # a 和 b 不同
139832578518984 139832578335520
>>> for x, y in zip(a, b):        # a 和 b 的子对象相同
...     print(id(x), id(y))
... 
139832578622816 139832578622816
139832578622672 139832578622672
139832578623104 139832578623104
>>> print(id(a), id(c))           # a 和 c 不同
139832578518984 139832578622456
>>> for x, y in zip(a, c):        # a 和 c 的子对象也不同
...     print(id(x), id(y))
... 
139832578622816 139832578621520
139832578622672 139832578518912
139832578623104 139832578623392
```



参考：

https://songlee24.github.io/2014/08/15/python-FAQ-02/