---
title: 函数——参数传递
date: 2021-07-27 10:04:43
categories:
- Python
---
#### fun1(a, b, c)

`fun1(a,b,c)`是直接将实参赋予行参，根据位置做匹配，即严格要求实参的数量与行参的数量位置相等，比较一般，大多数语言常用这种方式。

#### fun2(a=1,b=2,c=3)

`fun2(a=1,b=2,c=3)`根据键值对的形式做实参与行参的匹配，通过这种式就可以忽略了参数的位置关系，直接根据关键字来进行赋值，同时该种传参方式还有个好处就是可以在调用函数的时候作为个别选填项，不要求数量上的相等，即可以`fun5(3,4)`来调用fun2函数，这里关键就是前面的3,4覆盖了原来a、b两个行参的值，但c还是不变采用原来的默认值3，这种模式相较第一种更加灵活，不仅可以通过`fun6(c=5,a=2,b=7)`来打乱行参的位置，而且可以在但没有对应行参传递的时候常用定义函数时的默认值。

#### fun3(*args)

`fun3(*args)`，这传参方式是可以传入任意个参数，这些若干参数都被放到了tuple元组中赋值给行参args，之后要在函数中使用这些行参，直接操作args这个tuple元组就可以了，这样的好处是在参数的数量上没有了限制，但是因为是tuple，其本身还是有次序的，这就仍然存在一定的束缚，在对参数操作上也会有一些不便

#### fun4(**kargs)

`fun4(**kargs)`最为灵活，其是以键值对字典的形式向函数传参，含有第二种位置的灵活的同时具有第三种方式的数量上的无限制。此外第三四种函数声明的方式前的’*‘,与c里面的指针声明一样，这里仅做声明标识之用

最后要强调的是四种传递方式混合使用(大多数情况是这种),`fun7(a,b,*c,**d)`,但四种方式混用时要遵守：

> - args = 须在args之后
> - *args须在args=value之后
> - **kargs须在*args之后

赋值过程为：

> 1. 按顺序把传给args的实参赋值给对应的行参
> 2. args = value 形式的实参赋值给行参
> 3. 将多余出的即键值对行后的零散实参打包组成一个tuple传递给*args
> 4. 将多余的key=value形式的实参打包正一个dicrionary传递给**kargs



#### 1. 参数的顺序

必选参数，默认参数，可变参数

## 2. 可变参数

把多个参数传入函数中默认以tuple形式处理

```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

>>> calc(1, 3, 5, 7)
84
>>> calc()
0
```

调用该函数时，可以传入任意个参数，包括0个参数：

#### 实参为列表

```ruby
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
```

总结：在实参处，是一个一个的值，或`*列表名`；在形参处，自动组合为tuple

## 3. 关键字参数

**可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple,而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict**。

```python
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```

```ruby
>>> person('Michael', 30)
name: Michael age: 30 other: {}
```

```ruby
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```



#### 实参为字典

```ruby
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```



#### 命名关键字

```python
def person(name, age, *, city, job):
    print(name, age, city, job)
```

```shell
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer

>>> person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() takes 2 positional arguments but 4 were given    
```

命名关键字参数可以有缺省值，从而简化调用：

```python
def person(name, age, *, city='Beijing', job):
 print(name, age, city, job)
```



由于命名关键字参数city具有默认值，调用时，可不传入city参数：



```ruby
>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
```



## 3. 参数组合

```python
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
```



总结：

可变参数既可以直接传入：`func(1, 2, 3)`，又可以先组装list或tuple，再通过`*args`传入：`func(*(1, 2, 3))`；

关键字参数既可以直接传入：`func(a=1, b=2)`，又可以先组装dict，再通过`**kw`传入：`func(**{'a': 1, 'b': 2})`。

使用`*args`和`**kw`是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数不要忘了写分隔符*，否则定义的将是位置参数。



参考：https://www.jianshu.com/p/98f7e34845b5