### 声明与定义

- 声明：仅是告诉编译器该符号的存在，至于该符号的具体的含义，只有等链接的时候才能知道

- 定义：将某个符号完整的描述清楚，它是变量还是函数，变量类型以及变量值是多少，函数的参数有哪些以及返回值是什么等等

通过 《用g++命令执行C++多文件项目》一节的学习我们知道，**同属一个 C++ 项目中的所有代码文件是分别进行编译的，只需要在编译成目标文件后再与其它目标文件做一次链接即可**。例如，在 a.cpp 源文件中定义有一个全局函数 a()，而在文件 b.cpp 中需要调用这个函数。即便如此，**处于编译阶段的 a.cpp 和 b.cpp 并不需要知道对方的存在，它们各自是独立编译的，只要最后将编译得到的目标文件进行链接，整个程序就可以运行**。

那么，**整个过程是如何实现的呢？**从写程序的角度来理解，当文件 b.cpp 中需要调用 a() 函数时，**只需要先声明一下该函数即可**。这是因为，**编译器在编译 b.cpp 时会生成一个符号表，类似 a() 这样看不到定义的符号就会被存放在这个表中。在链接阶段，编译器就会在别的目标文件中去寻找这个符号的定义，一旦找到了，程序也就可以 顺利地生成了（反之则出现链接错误）**。



**在 C++ 项目中，一个符号允许被声明多次，但只能被定义一次。理由很简单，如果一个符号出现多种定义，编译器该采用哪一个呢**

**基于声明和定义的不同，才有了 C++ 多文件编程的出现**。试想如果有一个很常用的函数 f()，其会被程序中的很多 .cpp 文件调用，那么我们只需要在一个文件中定义此函数，然后在需要调用的这些文件中声明这个函数就可以了。

### 头文件

它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码，唯一的区别在于**头文件不用被编译**。

我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要时，可以通过 #include 宏命令直接将头文件中的所有内容引入到 .cpp 文件中。这样，当 .cpp 文件被编译之前（也就是预处理阶段），使用 #include 引入的 .h 文件就会**替换成**该文件中的所有声明。

### 示例

拥有 student.h、student.cpp 和 main.cpp 这 3 个文件，其中 student.cpp 和 main.cpp 文件中用 #include 引入了 student.h 文件。在此基础上，文章中用 g++ 命令分别对 student.cpp 和 main.cpp 进行了预处理操作，并分别生成了 student.i 和 main.i 文件。

显然和之前的 main.cpp 文件相比，抹去了用 #include 引入 student.h 文件，而是将 student.h 文件**中所有的内容都拷贝了过来**。

**#include** 是一个**来自 C 语言的宏命令**，作用于程序执行的预处理阶段，其功能是将它后面所写文件中的内容，完完整整、一字不差地**拷贝到当前文件中**。

### 头文件内容

头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件**的内容**实际上是会被引入到多个不同的 .cpp 文件中的，**并且它们都会被编译**。

#### 3种例外（可以定义）

- const对象：把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同理，static对象也可以。
- 内联函数：
- 类：在编译的时候编译器才知道怎么为对象分配空间。把定义放在头文件，而把成员函数的实现放在另一个cpp中。还有另一种办法，就是直接成员函数的实现代码写到类定义的内部。**在 C++ 的类中，如果成员函数直接定义在类体的内部，则编译器会将其视为内联函数。所以把函数成员的定义写进类体内，一起放进头文件中，也是合法的**。注意，**如果把成员函数的定义写在定义类的头文件中，而没有写进类内部，这是不合法的。这种情况下，此成员函数不是内联函数，一旦头文件被两个或两个以上的 .cpp 文件包含，就可能会出现重定义的错误**

### 编译

```C++
g++ -c main.cpp -o main.o
g++ -c fun.cpp -o fun.o
g++ main.o fun.o -o out
```

