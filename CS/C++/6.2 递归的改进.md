---
title: 6.1 递归
date: 2021-07-27 10:03:06
categories:
- data_structure
---
递归可能占用大量栈；解决方案：

- 改用循环


```C++
// 递归
long fact(int n)

{

　　if (n==0) return 1;

　　else return n*fact(n-1);

}
// 循环
long fact(int n)

{

　　int s=0;

　　for (int i=1; i<=n;i++)

　　s=s*i; //用s保存中间结果

　　return s;

}
```
- 尾递归，但很多语言不支持
### 尾递归

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。


#### 与递归的区别

阶乘函数递归实现

```c++
int fact(int n) {
    if (n < 0)
        return 0;
    else if(n == 0 || n == 1)
        return 1;
    else
        return n * fact(n - 1);
}
```

尾递归：

```c++
int facttail(int n, int res)
{
    if (n < 0)
        return 0;
    else if(n == 0)
        return 1;
    else if(n == 1)
        return res;
    else
        return facttail(n - 1, n *res);
}

```

函数比代码1多个参数res，除此之外并没有太大区别。res（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令res=n*res并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回res即可。不需要维护栈了。

#### 优势

在c++中不明显，在prolog等有明确循环结构的语言中，优势突出。

但在函数由循环等结构（如有if，go to）语言中，不推荐使用。