---
title: 12. 实用结构——伸展树
date: 2021-07-27 10:03:06
categories:
- data_structure
---
对于二叉查找树来说，每次操作最坏情形时间O(N)并非不好，只要它相对不经常发生即可。但是累积的时间很重要

伸展树保持M次对树操纵最多花费O(M f(N))时间，那么摊还时间为O(f(N))。这里是O(log(N))

基本想法：当一个结点被访问后，他就要经过一系列AVL树的旋转被推到根上。不保留高度信息。

好处：当访问路径长而超出正常查找时间，这些旋转对未来的操作有利



一般伸展树：向下查找，然后自底向上旋转，这样需要大量开销

自顶向下伸展树：在向下寻找元素的同时展开旋转。

## 自顶向下伸展树

做法：

- 先新建左右空子树，左子树都是小于当前结点x的值，右子树都是大于x的，且左右子树暂时不连接到中子树
- 旋转（单旋转，一字型旋转，之字形旋转）
- 组装为一棵树

#### 单旋转

情形：X节点是当前节点，其左儿子Y在展开路径上，当其左儿子Y是一个叶子节点或者只有右儿子（即没有左儿子），这种情形下进行单旋转（编程时无需任何rotate操作，只需通过改变相关节点的链即可实现）

做法：

Y成为新的中子树，X和子树B连接成为R中最小项的左儿子

![image-20210723100747103](../imags/image-20210723100747103.png)

#### 一字型（长结点XYZ一字型）

X节点是当前节点，其左儿子Y在展开路径上，且**Y的左儿子Z也在展开路径**上，

![image-20210723100923272](../imags/image-20210723100923272.png)

做法：



#### 之字形（长结点为之字形）

X节点是当前节点，其左儿子Y在展开路径上，且**Y的右儿子Z也在展开路径**上

![image-20210723101415018](../imags/image-20210723101415018.png)

![img](https://upload-images.jianshu.io/upload_images/21376615-3db8be1c459d1735.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

#### 合并

因为**L树中的所有元素均小于中间树**的任何元素，所以X的左子树成为L的右子树；**R树中的所有元素均大于中间树**的任何元素，所以X的右子树成为R的左子树。

### 程序实现