---
title: 虚函数和多态
date: 2021-07-27 09:59:04
categories:
- C++
---
## C++多态与虚函数

多态是一种思想，虚函数是实现这个思想的语法基础。

派生一个类的原因并非总是为了继承或是添加新的成员，**有时是为了重新定义基类的成员**，使得基类成员“获得新生”。面向对象的程序设计真正的力量不仅仅是继承，而且还在于允许派生类对象像基类对象一样处理，其核心机制就是多态和动态联编。

基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**。

多态性是指**具有不同功能的函数可以使用一个函数名**，这样可以用同一函数名实现不同的功能。

在系统的角度上看，多态分为静态多态和动态多态。静态多态是利用**函数重载**实现，在程序**编译**时确定要调用哪一个函数，因此静态多态又称为编译多态。动态多态是利用**虚函数实现**的，在程序**执行**期间才动态确定操作所针对的对象，因此动态多态又称为运行多态。



## 虚函数

#### 纯虚函数

父类没有定义，直接给了函数名，由子类自行定义

- virtual void fun() = 0; // 这是纯虚函数的形式，没有函数体。
- 纯虚函数可以没有函数实现，有纯虚函数的类不能实例化对象，继承有纯虚函数的父类的子类必须在子类中实现它，子类才能实例化对象，如果不在子类中实现它，子类也不能实例化对象

#### 一般虚函数

- 子类重写的函数默认是虚函数，也可以显式的加上 virtual，也可以不加; 

- 在一般成员函数前面加 virtual 即可将成员函数声明为虚函数

```cpp
class Test {
public:
    virtual void func() {  // 虚函数
        cout << "virtual function" << endl;
    }
};

Test().func(); 
```



- 在单一 class 中实现虚函数意义并不大，虚函数主要是为了实现子类函数重写父类函数的作用
- 要实现多态，通常父类中的虚函数与子类中的函数的返回值类型、函数名和参数列表必须都相同的，但是在协变的情况下返回值类型可以不一样，**协变即虚函数的返回值类型为所在类的指针或引用**

```cpp
// ====== 一般多态的实现 ======
class TestA {
public:
    virtual void vfunc() {
        cout << "TestA virtual function" << endl;
    }

    virtual ~TestA() { }
};

class Test : public TestA {
public:
    virtual void vfunc() {  // 子类的 virtual 可写可不写
        cout << "Test virtual function" << endl;
    }

    ~Test() { }
};

TestA* t = new Test; // 父类指针指向子类空间(多态的实现)
t->vfunc();          // 运行结果：Test virtual function，父类指针调用子类函数(多态的实现)
delete t;

// ====== 协变的情况 ======
class TestA {
public:
    virtual TestA& vfunc() {  // 或者是 virtual TestA* vfunc() 返回所在类的指针
        cout << "TestA virtual function" << endl;
        return *this;         // return this; 对应返回所在类的指针
    }

    virtual ~TestA() { }
};

class Test : public TestA {
public:
    virtual Test& vfunc() {
        cout << "Test virtual function" << endl;
        return *this;
    }

    ~Test() { }
};

TestA* t = new Test; // 父类指针指向子类空间(多态的实现)
t->vfunc();          // 运行结果：Test virtual function，父类指针调用子类函数(多态的实现)
delete t;
```

### 构造与析构

 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。

原因：

- 派生类不能继承基类的构造函数
- 造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在

析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。

- 避免内存泄漏问题。

### 构成多态的条件

- 必须存在继承关系；
- 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。
- 存在**基类的指针，通过该指针调用虚函数**。

### 抽象类

包含**纯虚函数**的**类**称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是**无法创建对象**。纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间

### 一个实例

在面向对象的程序设计中，使用多态能够增强程序的可扩充性，即程序需要修改或增加功能时，**只需改动或增加较少的代码**。此外，使用多态也能起到精简代码的作用。本节通过两个实例来说明多态的作用。

#### 游戏说明

“魔法门”游戏中有各种各样的怪物，如骑士、天使、狼、鬼，等等。每个怪物都有生命力、攻击力这两种属性。怪物能够互相攻击。一个怪物攻击另一个怪物时，被攻击者会受伤；同时，被攻击者会反击，使得攻击者也受伤。但是一个怪物反击的力量较弱，只是其自身攻击力的 1/2。

先介绍不用多态的写法。假定用 CDmgon 类表示龙，用 CWolf 类表示狼，用 CGhost 类表示鬼，则 CDragon 类的写法大致如下（其他类的写法与之类似）：

```cpp
class CDragon
{
private:
    int power;  //攻击力
    int lifeValue;  //生命值
public:
    void Attack(CWolf * p);  //攻击“狼”的成员函数
    void Attack(CGhost* p);  //攻击“鬼”的成员函数
                             //……其他 Attack 重载函数
                             //表现受伤的成员函数
    void Hurted(int nPower);
    void FightBack(CWolf * p);  //反击“狼”的成员函数
    void FightBack(CGhost* p);  //反击“鬼”的成员函数
                                //......其他FightBack重载函数
};
```



#### 多态

在非多态的实现中，使代码更精简的做法是将 CDragon、CWolf 等类的共同特点 抽取出来，形成一个 CCreature 类，然后再从 CCreature 类派生出 CDragon、CWolf 等类。但是由于每种怪物进行攻击、反击和受伤时的表现动作不同，CDmgon、CWdf 这些类还要实现各自的 Hurted 成员函数，以及一系列 Attack、FightBack 成员函数。因此，如果没有利用多态机制，那么即便引人基类 CCreature，对程序的可扩充性也没有太大帮助。

下面再来看看，如果使用多态机制编写这个程序，在要新增 CThunderBird 类时，程序改动的情况。使用多态的写法如下：设置一个基类 CCreature，概括所有怪物的共同特点。所有具体的怪物类，如 CDragon、CWolf、CGhost 等，均从 CCreature 类派生而来。下面是 CCreature 类的写法：

```cpp
class CCreature {  //“怪物”类
protected:
    int lifeValue, power;
public:
    virtual void Attack(CCreature* p) {};
    virtual void Hurted(int nPower) {};
    virtual void FightBack(CCreature* p) {};
};

class CDragon : public CCreature
{
public:
    virtual void Attack(CCreature* p) {
        p->Hurted(power);
        p->FightBack(this);
    }
    virtual int Hurted(int nPower) {
        lifeValue -= nPower;
    }
    virtual int FightBack(CCreature* p) {
        p->Hurted(power / 2);
    }
};
```



[C++多态与虚函数 (biancheng.net)](http://c.biancheng.net/cplus/polymorphism/)

参考：http://c.biancheng.net/view/265.html

