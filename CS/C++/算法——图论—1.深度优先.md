### 深度优先(Depth-First-Search)

它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。
当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
这一过程一直进行到已发现从源节点可达的所有节点为止。最适合用递归。

- 递归调用自身（用栈实现）
- 标记访问的点，确保仅访问一次；



#### 用途

产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。

#### 实现

**算法步骤**：

1. 访问顶点v；
2. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。



```C++
#include <iostream>
using namespace std;
 
int n, m, s;
int a[2001][2001];
bool visited[2001]; //访问标记 
 
void build_graph() {
	int x, y;
	cin >> n >> m >> s;
	for(int i=1; i<=m; i++) {
		cin >> x >> y;
		a[x][y] = a[y][x] = 1;
	}
}
 
void dfs(int x) {					  //以x为起点深搜
	if(visited[x] == true) return;
	visited[x] = true;
	cout << x << " -> ";
	for(int i=1; i<=n; i++)
		if(!visited[i] && a[x][i] == 1) //x和y有边相连并且i没有访问过
			dfs(i); 
}
 
int main() {
	build_graph();
	dfs(s); //以s为起点深搜 
}
```







参考：[DFS（深度优先搜索）和BFS(广度优先搜索) - 简书 (jianshu.com)](https://www.jianshu.com/p/b086986969e6)

[DFS（图论） - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/dfs/)