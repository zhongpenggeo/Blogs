### 缓冲区的意义

先写入内存缓冲区（速度快），当缓冲区刷新时，才写入IO/设备中。

为什么要有缓冲区，而不是与相关的文件/设备进行直接的读写操作。提出这个问题是很显然的。这是因为任何决定都是一种在代价和收益中的权衡。考虑到加上缓冲区是有代价的（代码变得更加复杂、需要控制的内容增多），所以加上缓冲区必然有随之而来的收益。众所周知，相对于 CPU 的指令执行和主存访问，I/O 操作是非常慢的。这也就是说，在不考虑缓冲区的情况下，如果程序有频繁的 I/O 操作，那么相当于程序的「高速」部分就会被频繁打断。这对于程序的整体性能是不利的。有了缓冲区，程序就可以避免频繁的 I/O 操作，而是对缓冲区进行读写，只有在必须的情况下，才通过刷新缓冲区进行真实的 I/O 操作。这样一来，程序就能将多个缓慢的 I/O 操作合并成一个，从而在整体上提高了程序的性能。

### 刷新缓冲区

缓冲刷新（数据真正写到输出设备或文件）的原因

- 程序正常结束，作为 main() 函数的 return 操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
- 我们可以使用操纵符如 endl 来显式刷新缓冲区。
- 在每个输出操作之后，我们可以用操作符 unitbuf 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此写到 cerr 的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin 和 cerr 都关联到 cout。因此，读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。

#### 刷新输出缓冲区

endl换行并刷新缓冲区；

- flush 和 ends。flush 刷新缓冲区，但不输出任何额外的字符；
- ends向缓冲区插入一个空字符，然后刷新缓冲区

```C++
cout << "hi!" << endl;  //输出hi和一个换行，然后刷新缓冲区
cout << "hi!" << flush;  //输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi!" << ends;  //输出hi和一个空字符，然后刷新缓冲区
```

#### unitbuf

```C++
cout << unitbuf;  //所有输出操作后都会立即刷新缓冲区
//任何输出都立即刷新，无缓冲
cout << nounitbuf;  //回到正常的缓冲方式
```

 **警告：如果程序崩溃，输出缓冲区不会被刷新**



参考：[C++如何管理输出缓冲区？ (biancheng.net)](http://c.biancheng.net/view/vip_7684.html)