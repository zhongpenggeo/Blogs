### 1. 递归的基本要素

1. 终止条件：即递归退出条件
2. 递归模式：大问题是如何分解为小问题的，也称为递归体

```
递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）
```

提高效率参考：[6.2 递归的改进](./6.2 递归的改进.md)

### 2. 状态维持（以python为例）

当处理递归函数时，每次递归调用都有自己的执行上下文，即每次递归调用之间的状态都是独立的。当我们想每次递归的时候都更新一个状态，并得到最后的更新结果，那该怎么办呢？为了维持递归中想要维持的状态，我们有两种方法可以使用：

- 将状态嵌入到每一次的递归调用中作为参数：要最终的输出变量作为函数的输入参数调用

- 将状态设置为全局变量：设置全局变量（python容易出问题）



### 3. 二分法实例

```python
data = [1,3,6,13,56,123,345,1024,3223,6688]
def dichotomy(min,max,d,n):
    '''
    min表示有序列表头部索引
    max表示有序列表尾部索引
    d表示有序列表
    n表示需要寻找的元素
    '''
    mid = (min+max)//2
    if mid==0:
        return 'None'
    elif d[mid]<n:
        print('向右侧找！')
        return dichotomy(mid,max,d,n)
    elif d[mid]>n:
        print('向左侧找！')
        return dichotomy(min,mid,d,n)
    else:
        print('找到了%s'%d[mid])
        return 
res = dichotomy(0,len(data),data,222)
print(res)
```



