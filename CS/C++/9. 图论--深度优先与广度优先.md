### 深度优先(Depth-First-Search)

它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。
当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
这一过程一直进行到已发现从源节点可达的所有节点为止。

最适合用递归？

#### 用途

产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。

#### 实现

一般用**堆数据**结构来辅助实现DFS算法。



### 广度优先(Breadth-First-Search)

简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。
如果所有节点均被访问，则算法中止。
BFS同样属于盲目搜索。
一般用**队列数据**结构来辅助实现BFS算法。

```python
#coding=utf-8 
class Gragh():
    def __init__(self,nodes,sides):
        '''
        nodes 表示点
        sides 表示边

        '''
        # self.sequense是字典，key是点，value是与key相连接的点
        self.sequense = {}
        # self.side是临时变量，主要用于保存与指定点相连接的点
        self.side=[]
        for node in nodes:
            for side in sides:
                u,v=side
                # 指定点与另一个点在同一个边中，则说明这个点与指定点是相连接的点，则需要将这个点放到self.side中
                if node ==u:
                    self.side.append(v)
                elif node == v:
                    self.side.append(u)
            self.sequense[node] = self.side
            self.side=[]
        #print self.sequense


    '''
    # Depth-First-Search 
        深度优先算法，是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
        当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
        这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，
        则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。        
    '''
    def DFS(self,node0):
        #queue本质上是堆栈，由于树状结构，需要先存储遍历结果和顺序
        #order里面存放的是具体的访问路径
        queue,order=[],[]
        #首先将初始遍历的节点放到queue中，表示将要从这个点开始遍历
        queue.append(node0)
        while queue:
            #从queue中pop出点v，然后从v点开始遍历了，所以可以将这个点pop出，然后将其放入order中
            v = queue.pop() # 弹出最后遍历的元素，即深度遍历
            order.append(v)

            #这里开始遍历v的子节点
            for w in self.sequense[v]: 
                #w既不属于queue也不属于order，意味着这个点没被访问过，所以讲起放到queue中，然后后续进行访问
                if w not in order and w not in queue:  # queue + order = 所有遍历过的节点
                    queue.append(w)
        return order

    '''
     readth-First-Search
     BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
           广度优先搜索的实现一般采用open-closed表。
    '''
    def BFS(self,node0):
        #queue本质上是堆栈，用来存放需要进行遍历的数据
        #order里面存放的是具体的访问路径
        queue,order = [],[]
        #首先将初始遍历的节点放到queue中，表示将要从这个点开始遍历
        # 由于是广度优先，也就是先访问初始节点的所有的子节点，所以可以
        queue.append(node0)
        order.append(node0)
        while queue:
            v = queue.pop(0) # 弹出父结点（队列）
            for w in self.sequense[v]:
                if w not in order: # order中就是树结构的表状存储（遍历顺序与结构顺序一致）
                    # 这里可以直接order.append(w) 因为广度优先就是先访问节点的所有下级子节点，所以可以
                    # 将self.sequense[v]的值直接全部先给到order
                    order.append(w)
                    queue.append(w)
        return order

nodes = [i+1 for i in range(8)]

sides=[(1, 2),
    (1, 3),
    (2, 4),
    (2, 5),
    (4, 8),
    (5, 8),
    (3, 6),
    (3, 7),
    (6, 7)]
G = Gragh(nodes,sides)
print(G.DFS(1))
# print G.BFS(1)
# print G.DFS1(1)
```







参考：[DFS（深度优先搜索）和BFS(广度优先搜索) - 简书 (jianshu.com)](https://www.jianshu.com/p/b086986969e6)