### POSIX 标准

POSIX 标准全称“**P**ortable **O**perating **S**ystem **I**nterface”，中文译为可移植操作系统接口，最后的字母 X 代指类 UNIX 操作系统。简单地理解，POSIX 标准发布的初衷就是为了统一所有类 UNIX 操作系统的接口，这意味着，只要我们编写的程序严格按照 POSIX 标准调用系统接口，它就可以在任何兼容 POSIX 标准的类 UNIX 系统上运行。

### 线程创建和使用

C++11 标准中，`<thread>`头文件提供了 thread 类（位于 std 命令空间中），专门用来完成线程的创建和使用。

#### 初始化方式

```C++
//1、Fn 表示线程要执行的函数，args 表示向 Fn 传递的多个参数，此构造函数支持泛型
template <class Fn, class... Args>
explicit thread (Fn&& fn, Args&&... args);
//2、移动构造函数
thread (thread&& x) noexcept;
```

注意，thread 类只提供了移动构造函数，未提供拷贝构造函数。这意味着，我们不能直接将一个事先定义好的 thread 对象赋值给另一个 thread 对象，但可以将临时的（匿名的）thread 对象赋值给另一个 thread 对象。有关移动构造函数，读者可阅读《[C++11移动构造函数详解](http://c.biancheng.net/view/7847.html)》一文做详细了解。

POSIX 标准中，线程所执行函数的参数和返回值都必须为 void* 类型。而 thread 类创建的线程可以执行任意的函数，即不对函数的参数和返回值做具体限定。

```C++
#include <iostream>
#include <thread>
using namespace std;

void threadFun1(int n) {
    cout << "---thread1 running\n";
    cout << "n=" << n << endl;
}

void threadFun2(const char * url) {
    cout << "---thread2 running\n";
    cout << "url=" << url << endl;
}

int main() {
    //调用第 1 种构造函数
    thread thread1(threadFun1,10);
    //调用移动构造函数
    thread thread2 = std::thread(threadFun2,"http://c.biancheng.net");
    //阻塞主线程，等待 thread1 线程执行完毕
    thread1.join();
    //阻塞主线程，等待 thread2 线程执行完毕
    thread2.join();
    return 0;
}
```

注意编译时要加上`-pthread`参数

```Shell
clang++-3.7 -std=c++11 -pthread test.cpp
```

#### 使用

| 成员函数   | 功 能                                                        |
| ---------- | ------------------------------------------------------------ |
| get_id()   | 获取当前 thread 对象的线程 ID。                              |
| joinable() | 判断当前线程是否支持调用 join() 成员函数。                   |
| join()     | 阻塞当前 thread 对象所在的线程，直至 thread 对象表示的线程执行完毕后，所在线程才能继续执行。 |
| detach()   | 将当前线程从调用该函数的线程中分离出去，它们彼此独立执行。   |
| swap()     | 交换两个线程的状态。                                         |

`<thread>`头文件中不仅定义了 thread 类，还提供了一个名为 this_thread 的命名空间，此空间中包含一些功能实用的函数，如表 2 所示



| 函数          | 功 能                                     |
| ------------- | ----------------------------------------- |
| get_id()      | 获得当前线程的 ID。                       |
| yield()       | 阻塞当前线程，直至条件成熟。              |
| sleep_until() | 阻塞当前线程，直至某个时间点为止。        |
| sleep_for()   | 阻塞当前线程指定的时间（例如阻塞 5 秒）。 |

### 线程同步

C++11标准规定，互斥锁用 mutex 类（位于 std 命名空间中）的对象表示，该类定义在`<mutex>`头文件中。mutex 类提供有 lock() 和 unlock() 成员函数，分别完成“加锁”和“解锁”功能。

```C++
#include <mutex>          // std::mutex
#include <chrono>         // std::chrono::seconds()
using namespace std;
int  n = 0;
std::mutex mtx;           // 定义一个 mutex 类对象，创建一个互斥锁
void threadFun() {
    while(n<10){
        //对互斥锁进行“加锁”
        mtx.lock();
        n++;
        cout << "ID" << std::this_thread::get_id() << " n = "<< n << endl;
        //对互斥锁进行“解锁”
        mtx.unlock();
        //暂停 1 秒
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
int main()
{
    thread th1(threadFun);
    thread th2(threadFun);
    th1.join();
    th2.join();
    return 0;
```

#### 条件变量

```C++
#include <iostream>
#include <thread>             // std::thread
#include <mutex>              // std::mutex, std::unique_lock
#include <condition_variable> // std::condition_variable_any
#include <chrono>         // std::chrono::seconds()
//创建一个互斥锁
std::mutex mtx;
//创建一个条件变量
std::condition_variable_any cond;
void print_id() {
    mtx.lock();
    //阻塞线程，直至条件成立
    cond.wait(mtx);
    std::cout << "----threadID " << std::this_thread::get_id() <<" run" << std::endl;
    //等待 2 秒
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mtx.unlock();
}
void go() {
    std::cout << "go running\n";
    //阻塞线程 2 秒钟
    std::this_thread::sleep_for(std::chrono::seconds(2));
    //通知所有等待的线程条件成立
    cond.notify_all();
}
int main()
{
    //创建 4 个线程执行 print_id() 函数
    std::thread threads[4];
    for (int i = 0; i < 4; ++i)
        threads[i] = std::thread(print_id);
    //创建 1 个线程执行 go() 函数
    std::thread goThread(go);
    //等待所有线程执行结果后，主线程才能继续执行
    goThread.join();
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

