---
title: 1. 参数传递
date: 2021-07-27 09:59:04
categories:
- C++
---
## 0. 一般调用方式
在C和Java中，使用**按值调用**，即实参是直接**复制**给形参；  
C++中，有其他方式；
### 0.1 引用
```C++
double avg(const vector<int> &arr, int a, bool &errorFlag)
```
这里是引址调用，有一下情况必须使用这种调用方式；
1. 如果形参必须能够改变实参的值
2. 如果是class类型  
引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
### 0.2 按值调用
即一般的调用方式
### 0.3 指针调用

指针调用传入的是一个地址，类似于按值调用，只不过这个值是一个地址。  
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）

### 引用和指针调用的区别
指针是一个实体，而**引用仅是别名**；

●引用只能在定义时被初始化一次，之后不可变；**指针可变**；引用“从一而终”，指针可以“见异思迁”；

●引用没有**const**，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

●引用**不能为空**，指针可以为空；

●“**sizeof** 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；
```C++
int a=0;
int b=&a;
int *p=&a;
```
b++;相当于a++;b只是a的一个别名，和a一样使用。  
p++;后p指向a后面的内存  
(\*p)++;相当于a++  

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

## 形参与实参

### 定义

- 形参：定义函数中，用于函数体内，离开函数不能使用
- 实参：主调函数中

调用过程：

- 若形参不是引用，则实参会**复制副本**后进入函数的形参中，所以形参的改变不影响实参。

- 如果形参为引用类型（即地址），则它只是实参的别名。





形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。

- 普通变量时值传递，函数使用该变量的拷贝，不能改变原来变量的值。

- 如果是指针，是地址的一个拷贝，其实也是值传递（地址的值传递）。你不能改变原来变量（地址）的值，但能改变这个地址指向的内容，即所谓的实参被改变了。

- 如果是引用，传递的也是一个地址，不过这个地址又解析过了的，所以能直接用，不用再加*去解析（地址值传递，用时已经解析了）。改变值同指针一样，不过不能改变地址就更明显了（引用其实是一个解析了的const 指针）
- 传递数组时，函数将使用原来的数组。因为此时函数传递的是数组的地址（数组名）。将数组地址作为参数可以节省复制整个数组所需的时间和内存。

## 返回值传递
### 1. 按值返回

使用临时对象（temporary object）来保存函数的返回值。

函数的返回值用于初始化调用点的一个临时对象，该临时对象就是函数调用的结果。

```C++
int func()
{
    int a = 1;
    return a;
}
int i = func();
```

```C++
char get_val(string& str, int index)
{
return str[index - 1];
}
string str = "12345";
char ch = get_val(str, 1);//ch的值是’1’
get_val(str, 1) = 'a';//编译时报错，error C2106: “=”: 左操作数必须为左值
```

### 2. 按引用返回

返回**引用**时不会产生值的副本

```C++      const string &mainip(const string &s)
const string &mainip(const string &s)
{
    string ret=s;
    return ret;
}
```

当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。

所以内存地址有效，但内部的值无效，只能作为左值使用。

```C++
char& get_val(string& str, int index)
{
return str[index - 1];
}
string str = "12345";
char ch = get_val(str, 1);//ch的值是’1’
get_val(str, 1) = 'a';//此时str的值为”a2345”
```

### 3. 返回指针

```C++
char* fun(int mod){
    switch(mod){
        case 0:{
            char a[] = "0123456";
            char *pa = a;
            pa[0]++;
            cout<<&pa<<"->"<<(void *)pa<<":"<<pa<<endl;
            return pa;
        }
        case 1:{
            static char a[] = "1234567";
            a[0]++;
            cout<<&a<<"->"<<(void *)a<<":"<<a<<endl;
            return a;
        }
        case 2:{
            char *a = "2345678";
//            a[0]++;  // 错误
            cout<<&a<<"->"<<(void *)a<<":"<<a<<endl;
            return a;
        }
        case 3:{
            char *a = new char[8]{'3','4','5','6','7','8','9','\0'};
            a[0]++;
            cout<<&a<<"->"<<(void *)a<<":"<<a<<endl;
            return a;
        }
        case 4:{
            static char *a = "4567890";
//            a[0]++;   // 错误
            cout<<&a<<"->"<<(void *)a<<":"<<a<<endl;
            return a;
        }
        case 5:{
            static char *a = new char[8]{'5','6','7','8','9','0','1','\0'};
            a[0]++;
            cout<<&a<<"->"<<(void *)a<<":"<<a<<endl;
            return a;
        }
        default:
            return NULL;
    }
}
```

- case 0中所声明的字符串数组保存在栈中，在函数返回时空间被释放，在测试结果中我们可以看到，函数返回后该地址处的数据还在，但随即便被其他值覆盖
- case 1中所声明的字符串数组由于添加了static关键字，字符串被保存在全局数据区，该区域在程序结束时由系统释放，所以我们可以通过指针访问到字符串。
- case 2中的字符串存放在常量区，不可修改，同样是在程序结束时由系统释放。
- case 3中通过new申请的内存空间位于堆中，并通过delete进行释放，由于在函数中我们并没有释放该处内存，所以当函数返回后可以通过指针进行访问。
- case 4、5中字符串分别保存在常量区与堆中，而指向字符串的指针位于全局数据区，所以在gdb中我们可以通过存放在全局数据区的字符串指针来访问字符串