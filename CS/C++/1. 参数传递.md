---
title: 1. 参数传递
date: 2021-07-27 09:59:04
categories:
- C++
---
## 0. 一般调用方式
在C和Java中，使用**按值调用**，即实参是直接**复制**给形参；  
C++中，有其他方式；
### 0.1 引用
```C++
double avg(const vector<int> &arr, int a, bool &errorFlag)
```
这里是引址调用，有一下情况必须使用这种调用方式；
1. 如果形参必须能够改变实参的值
2. 如果是class类型  
引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
### 0.2 按值调用
即一般的调用方式
### 0.3 指针调用

指针调用传入的是一个地址，类似于按值调用，只不过这个值是一个地址。  
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）

### 引用和指针调用的区别
指针是一个实体，而**引用仅是个别名**；

●引用只能在定义时被初始化一次，之后不可变；**指针可变**；引用“从一而终”，指针可以“见异思迁”；

●引用没有**const**，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

●引用**不能为空**，指针可以为空；

●“**sizeof** 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；
```C++
int a=0;
int b=&a;
int *p=&a;
```
b++;相当于a++;b只是a的一个别名，和a一样使用。  
p++;后p指向a后面的内存  
(\*p)++;相当于a++  

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

## 返回值传递
对于class类型，使用**按常量引用返回**可以减少复制的开销。这里容易出错，慎用。
## 1. 指针
用于存储变量的地址；  
```C++
int main()
{
    //声明*m为一个IntCell对象（应该时自己构造的对象）
    IntCell *m;
    
    m=new IntCell(0);
    m->write(5);
}
```