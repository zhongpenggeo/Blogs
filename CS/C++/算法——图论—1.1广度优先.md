### 广度优先(Breadth-First-Search)

简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。
如果所有节点均被访问，则算法中止。
BFS同样属于盲目搜索。
一般用**队列数据**结构来辅助实现BFS算法。

```c++
#include <iostream>
#include <queue>
using namespace std;
 
int n, m, s;
int a[2001][2001];
int visited[2001];       //访问标记 
bool inq[2001];          //在不在队列中
 
queue<int> q;
 
void build_graph() {
	int x, y;
	cin >> n >> m >> s;
	for(int i=1; i<=m; i++) {
		cin >> x >> y;
		a[x][y] = a[y][x] = 1;
	}
}
 
void bfs(int x) {
	int k;
	q.push(x);
	inq[x] = true;
	while(!q.empty()) {
		k = q.front();
		q.pop();
		cout << k << " -> ";
		visited[k] = true;
		inq[k] = false;
		for(int i=1; i<=n; i++) {
			if(a[k][i] == 1 && !visited[i] && !inq[i]) {
				q.push(i);
				inq[i] = true;
			}
		}
	}
}
 
int main() {
	build_graph();
	bfs(s);
	return 0;
}
```



参考：[BFS（图论） - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/bfs/)