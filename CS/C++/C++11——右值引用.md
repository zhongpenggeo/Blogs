### 左值引用

```C++
int a = 10; // 被引用的值必须初始化，才有地址
int &b = a;  // 定义一个左值引用变量
b = 20;      // 通过左值引用修改引用内存的值
```

左值引用在汇编层面其实和普通的指针是一样的。（类似于别名？）



### 右值引用

用 "&&" 表示;必须初始化

```C++
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
```

右值引用还可以对右值进行修改。例如：

```c++
int && a = 10;
a = 100;
cout << a << endl;
```

C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：

- 可以取地址的，有名字的，非临时的就是左值；
- 不能取地址的，没有名字的，临时的就是右值；

可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。

### 作用

充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。

11标准之前，如果用其他对象初始化一个同类的新对象，只能借助类中的复制拷贝构造函数。底层实际上需要调用两次深拷贝操作。

所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。

当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常令其指向 NULL），这样就完成了 a.num 的初始化。

```C++
#include <iostream>
using namespace std;
class demo{
public:
    demo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    demo(const demo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //添加移动构造函数
    demo(demo &&d):num(d.num){
        d.num = NULL;
        cout<<"move construct!"<<endl;
    }
    ~demo(){
        cout<<"class destruct!"<<endl;
    }
private:
    int *num;
};
demo get_demo(){
    return demo();
}
int main(){
    demo a = get_demo();
    return 0;
}
```

输出结果为：

> construct!
> move construct!
> class destruct!
> move construct!
> class destruct!
> class destruct!

可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。



#### move函数

强制将左值转换为右值。

```C++
#include <iostream>
using namespace std;
class movedemo{
public:
    movedemo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    //拷贝构造函数
    movedemo(const movedemo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //移动构造函数
    movedemo(movedemo &&d):num(d.num){
        d.num = NULL;
        cout<<"move construct!"<<endl;
    }
public:     //这里应该是 private，使用 public 是为了更方便说明问题
    int *num;
};
int main(){
    movedemo demo;
    cout << "demo2:\n";
    movedemo demo2 = demo;
    //cout << *demo2.num << endl;   //可以执行
    cout << "demo3:\n";
    movedemo demo3 = std::move(demo);
    //此时 demo.num = NULL，因此下面代码会报运行时错误
    //cout << *demo.num << endl;
    return 0;
}
```

程序执行结果为：

> construct!
> demo2:
> copy construct!
> demo3:
> move construct!



### 用途

但要注意，我们这样使用有一个前提是：用a初始化b后，a我们就不需要了，最好是初始化完成后就将a析构。如果说，我们用a初始化了b后，仍要对a进行操作，用这种浅层复制的方法就不合适了。（因为a中的指针指向null了）

所以C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况。

移动构造函数应用最多的地方就是STL中

参考：[C++11右值引用（一看即懂） (biancheng.net)](http://c.biancheng.net/view/7829.html)

[C++移动构造函数以及move语句简单介绍 - 青儿哥哥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qingergege/p/7607089.html)